---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Bayesian Mixed (Spatial) Modeling
```{r, include=FALSE}
knitr::opts_chunk$set(echo = T, warning = F, message = F, eval = T, results = 'hide',
                      fig.align = 'center', fig.width = 8, fig.height = 8)
```
```{r}
#---------------------------------------------------------------------------
# Purpose of this script is to do basic epi analyses
#----------------------------------------------------------------------------
library(tidyverse)
library(CARBayes)
library(raster)
source("~/Documents/GitHub/Space_the_Final_Miptier/R/basics.R")
source("~/Documents/GitHub/Space_the_Final_Miptier/R/themes.R")
source("~/Documents/GitHub/Space_the_Final_Miptier/R/pairwise_helpers.R")

```

```{r}
drcsmpls <- readRDS("~/Documents/GitHub/Space_the_Final_Miptier/data/distance_data/drcsmpls_foruse.rds") %>%
  magrittr::set_colnames(tolower(colnames(.))) %>%
  dplyr::select(c("id", "hv001")) %>% 
  dplyr::rename(name = id)

mtdt <- readRDS("~/Documents/GitHub/Space_the_Final_Miptier/data/derived_data/sample_metadata.rds") %>% 
  magrittr::set_colnames(tolower(colnames(.))) %>%
  dplyr::rename(name = id) %>% 
  dplyr::select(c("name", "country", "hv001", "adm1name", "longnum", "latnum")) %>% 
  dplyr::filter(name %in% drcsmpls$name)

# drc prov for plot
DRCprov <- sf::st_as_sf(readRDS("~/Documents/GitHub/Space_the_Final_Miptier/data/map_bases/gadm/gadm36_COD_1_sp.rds")) 

# load pretty map aesthetics 
load("~/Documents/GitHub/Space_the_Final_Miptier/data/map_bases/space_mips_maps_bases.rda")
```

```{r}
#....................................................................................
# Import Genetic Data
#....................................................................................
ibD <- readRDS("~/Documents/GitHub/Space_the_Final_Miptier/data/derived_data/bigbarcode_genetic_data/mipanalyzer.DRCibD_polarized_biallelic_processed.long.rds")

# log2 IBD measure
ibD <- ibD %>% 
  dplyr::mutate(malecotf_gens = -log2(malecotf),
                malecotf_gens_inv = 1/malecotf_gens)

```

```{r}
#..............................................................
# mk mtdt 
#..............................................................
mtdt.clst <- mtdt %>% 
  dplyr::select(c("name", "hv001")) %>% 
  dplyr::rename(smpl1 = name)

ibD <- dplyr::left_join(ibD, mtdt.clst, by = "smpl1")

# rename
mtdt.clst <- mtdt.clst %>% 
  dplyr::rename(smpl2 = smpl1)
# rejoin
ibD <- dplyr::left_join(ibD, mtdt.clst, by = "smpl2")


#..............................................................
# Import geographic distance and combine with genetic
#..............................................................
distancematrix.cluster <- readRDS("~/Documents/GitHub/Space_the_Final_Miptier/data/distance_data/distancematrix_bycluster.rds")

ibDdist <- long_distance_matrix_join(x=ibD, y=distancematrix.cluster,
                                     by = c("hv001.x", "hv001.y")) %>%
  dplyr::mutate(gcdistance = gcdistance/1e3,
                roaddistance = roaddistance/1e3,
                riverdist = riverdist/1e3,
                riverdist = as.numeric(riverdist)) # remove units


# take care of cluster diagnonals
ibDdist$gcdistance[ibDdist$hv001.x == ibDdist$hv001.y] <- 0
ibDdist$roaddistance[ibDdist$hv001.x == ibDdist$hv001.y] <- 0
ibDdist$riverdist[ibDdist$hv001.x == ibDdist$hv001.y] <- 0

ibDdist.long <- ibDdist %>% 
  dplyr::select(-c(dplyr::starts_with("hv001"))) %>% 
  expand_distance_matrix(.)

```

<!-- TODO make above imported in already -->

## Epi Considerations
Here we will analyze IBD using a traditional epidemiological approach. _Outcome_: pairwise IBD comparisons; _Covariates_: Differences among observations; _Spatial Autocorrelation_: Random Intercepts (Province). Gaussian Process (Cluster). _Link/family_: Given that we can normalize the IBD pairwise outcome, we will use a log-link and the Gaussian probability family for our generalized linear models. A log-link will be used given the expected exponential relationship of IBD and distance/covariates.   
  
NB, all covariates were taken from open sources including: Malaria Atlas Project, European Space Agency, LAADS/NASA, and OSM (this include prevalence which is not from our lab but from MAP).



### Outcome
When considering pairwise IBD as the outcome, we can use a log-base-2 tranformation to normalize the IBD measure. Log-base-2 represents the number of generations ago to samples were IBD (or coalesced) under an assumption of outcrossing. N.B. larger numbers mean more generations (less related).
```{r, results='asis'}
ibDdist.long %>% 
  dplyr::filter(malecotf_gens != Inf) %>% 
  ggplot() + 
  geom_histogram(aes(x = malecotf_gens, y = ..count.. )) + 
  plot_theme +
  xlab("Generations") + ylab("")

```
Looks relatively normal considering... 

### Distribution of IBD-Gens by Prov
```{r, results='asis'}

p1 <- mtdt %>% 
  dplyr::select(c("name", "adm1name")) %>% 
  dplyr::rename(smpl1 = name)

p2 <- mtdt %>% 
  dplyr::select(c("name", "adm1name")) %>% 
  dplyr::rename(smpl2 = name)

ibDdist.long.mtdt <- ibDdist.long %>% 
  dplyr::left_join(., y = p1, by = "smpl1") %>% 
  dplyr::left_join(., y = p2, by = "smpl2")  

ibDdist.long.mtdt %>% 
  dplyr::filter(malecotf_gens != Inf) %>% 
  ggplot() + 
  ggridges::stat_density_ridges(
    geom = "density_ridges_gradient", calc_ecdf = T,
    quantiles = 4, quantile_lines = T, 
    aes(x = malecotf_gens, y = adm1name.x, fill = factor(..quantile..))
  ) +
  scale_fill_viridis_d("Quantiles") +
  ylab("Province") + xlab("Distribution of Generations") +
  plot_theme 
  
```


### Outcome Transformation
Given that we are making pairwise comparisons, traditional epidemiological approaches may be biased by correlation among observations (i.e. non-independence). To overcome this potential bias, we will fit a trend of IBD-decay with space and model that as the outcome. We will use the number of generations (log-base 2 transfomration) as it helps to normalize the data. Pairwise comparisons that do not coalesce will be excluded (i.e. _Inf_ values). Seperately, we will consider within-province IBD as an outcome. 

#### Lambda Fitting

```{r}
#..............................................................
# Fit the lambda distributions by prov
#..............................................................

ibDdist.prov.lambda <- ibDdist.long.mtdt %>% 
  dplyr::rename(riverdistance = riverdist) %>% 
  dplyr::select(c("smpl1", "smpl2", "adm1name.x", "adm1name.y", "malecotf", "malecotf_gens", dplyr::ends_with("distance"))) %>% 
  tidyr::gather(., key = "distcat", value = "geodist", 7:9) %>% 
  dplyr::group_by(adm1name.x, distcat) %>% 
  tidyr::nest()


ibDdist.prov.lambda$genbase2_fit <- purrr::map(ibDdist.prov.lambda$data, function(dat){
  dat <- dat %>% 
    dplyr::filter(malecotf_gens != Inf)
  ret <- glm(malecotf_gens ~ geodist,
             data = dat,
             family = gaussian(link = "log"))
  return(ret)
})

ibDdist.prov.lambda$genbase2_slope <- purrr::map(ibDdist.prov.lambda$genbase2_fit, function(fit){
  ret <- broom::tidy(fit) %>% 
    dplyr::filter(term == "geodist") %>% 
    dplyr::select("estimate") %>% 
    unlist(.) 
  return(ret)
})

ibDdist.prov.lambda <- ibDdist.prov.lambda %>% 
  tidyr::unnest(cols = "genbase2_slope")

```
```{r, results='asis'}
#..............................................................
# Fit by prov for slope
#..............................................................

ibDdist.prov.lambda %>% 
  ggplot() + 
  ggridges::geom_density_ridges_gradient(aes(x=genbase2_slope, y = adm1name.x)) +
  ggtitle("Dist of three Slopes for Geo-Gen Dist by Prov") +
  xlab("Slope of Gen-base2") + 
  plot_theme + 
  theme(axis.title.y = element_blank())


ibDdist.prov.lambda %>% 
  ggplot() + 
  ggridges::geom_density_ridges_gradient(aes(x=genbase2_slope, y = distcat)) +
  ggtitle("Dist of Geo-Gen Dist by Distcat") +
  xlab("Slope of Gen-base2") + 
  plot_theme + 
  theme(axis.title.y = element_blank())


```


## Province Models
### Covariate Considerations
```{r}
#..............................................................
# Import Covariates for Province
#..............................................................
provCovar.raw <- readRDS("data/derived_data/covar_rasterstack_provlocations_raw.RDS")

# transform covars
provCovar <- provCovar.raw %>%
  dplyr::mutate(
    prev = my.scale(logit(prev, tol = 0.1)),
    precip = my.scale(precip),
    temp = my.scale(temp),
    elev = my.scale(elev),
    crops = my.scale(logit(crops, tol = 0.1)),
    actuse = my.scale(logit(actuse, tol = 0.1)),
    netuse = my.scale(logit(netuse, tol = 0.1)),
    housing = my.scale(logit(housing, tol = 0.1))
  )


```

Here you can visualize the (scaled) covariate by province. 
**Note, the covariate X were standardized/scaled in order to account to promote model stability.** 
```{r}

provCovar.geo <- provCovar %>% 
  tidyr::gather(., key = "covar", value = "val", 2:ncol(.)) %>% 
  dplyr::left_join(DRCprov, 
                   y = ., by = "adm1name") 
provCovar.geo <- sf::st_as_sf(provCovar.geo)

provCovar.geo %>% 
  ggplot() + 
  geom_sf(aes(fill = val)) +
  facet_wrap(covar ~ .) + 
  scale_fill_distiller("Prevalence", type = "div", palette = "RdYlBu") +
  map_theme +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank())

```



## Hierarchial Bayesian Spatial Models for Province Gen-Geo 
### Make Model Framework
NB. Using the _Leroux et al. 2000_ specifiation of the Gaussian Markov Random Field, we will allow  $\rho$ to be estimated under the model.


### MCMC Diagnostics
Note, our goal is to have the effective sample sizes (`n.effective`) to be at least 500 for all parameters. In addition, we will visually check for convergence among the four chains.


```{r}
# clear memory for markdown
rm(list = ls())

provmodels <- readRDS("~/Documents/GitHub/Space_the_Final_Miptier/results/carbayes_sp_dics/params.RDS") %>% 
  dplyr::select(c("formula", "outcome", "distcat"))

# get all files
provformlist <- list.files("~/Documents/GitHub/Space_the_Final_Miptier/results/carbayes_sp_dics/",
                           pattern = ".RDS", full.names = T)
provformlist <- provformlist[!grepl("f.RDS|params.RDS", provformlist)]


provformlistdf <- tibble::tibble(
  path = provformlist
  ) %>% 
  dplyr::mutate(fileord = stringr::str_extract(path, "[0-9]+"),
                fileord = as.numeric(fileord)) %>% 
  dplyr::arrange(fileord)

# now get results 
provmodels$results <- unlist(purrr::map(provformlistdf$path, readRDS), 
                             recursive = F)

# now examine models
provmodels$min_nEff <- purrr::map(provmodels$results, function(x){
  return(min(x$n.effective))
})

provmodels$DIC <- purrr::map(provmodels$results, function(x){
  return(unique(x$DIC))
})

# select out what we need
provmodels <- provmodels %>% 
  dplyr::select(-c("results")) %>% 
  tidyr::unnest(cols = c("min_nEff", "DIC")) %>% 
  dplyr::mutate(formula = purrr::map(formula, function(x){
    return(paste(deparse(x), collapse = ""))
  }))

```

#### DICs Slope {.tabset .tabset-fade}
##### Greater Circle DICs 
```{r, results='asis'}

provmodels %>% 
  dplyr::select(c("formula", "distcat", "min_nEff", "DIC")) %>% 
  dplyr::filter(distcat == "gcdistance") %>% 
  dplyr::filter(outcome == "genbase2_slope") %>% 
  DT::datatable(.,
                rownames = F,
                options = list(
                  searching = F,
                  pageLength = 6,
                  dom = 'Bfrtip',
                  buttons = c('csv')))

```

##### Road DICs 
```{r, results='asis'}

provmodels %>% 
  dplyr::select(c("formula", "distcat", "min_nEff", "DIC")) %>% 
  dplyr::filter(distcat == "roaddistance") %>% 
  dplyr::filter(outcome == "genbase2_slope") %>% 
  DT::datatable(.,
                rownames = F,
                options = list(
                  searching = F,
                  pageLength = 6,
                  dom = 'Bfrtip',
                  buttons = c('csv')))

```

##### River DICs 
```{r, results='asis'}

provmodels %>% 
  dplyr::select(c("formula", "distcat", "min_nEff", "DIC")) %>% 
  dplyr::filter(distcat == "riverdistance") %>% 
  dplyr::filter(outcome == "genbase2_slope") %>% 
  DT::datatable(.,
                rownames = F,
                options = list(
                  searching = F,
                  pageLength = 6,
                  dom = 'Bfrtip',
                  buttons = c('csv')))

```

####


#### DICs Within Prov IBD {.tabset .tabset-fade}
##### Greater Circle DICs 
```{r, results='asis'}

provmodels %>% 
  dplyr::select(c("formula", "distcat", "min_nEff", "DIC")) %>% 
  dplyr::filter(distcat == "gcdistance") %>% 
  dplyr::filter(outcome == "withinprovIBD") %>% 
  DT::datatable(.,
                rownames = F,
                options = list(
                  searching = F,
                  pageLength = 6,
                  dom = 'Bfrtip',
                  buttons = c('csv')))

```

##### Road DICs 
```{r, results='asis'}

provmodels %>% 
  dplyr::select(c("formula", "distcat", "min_nEff", "DIC")) %>% 
  dplyr::filter(distcat == "roaddistance") %>% 
  dplyr::filter(outcome == "withinprovIBD") %>% 
  DT::datatable(.,
                rownames = F,
                options = list(
                  searching = F,
                  pageLength = 6,
                  dom = 'Bfrtip',
                  buttons = c('csv')))

```

##### River DICs 
```{r, results='asis'}

provmodels %>% 
  dplyr::select(c("formula", "distcat", "min_nEff", "DIC")) %>% 
  dplyr::filter(distcat == "riverdistance") %>% 
  dplyr::filter(outcome == "withinprovIBD") %>% 
  DT::datatable(.,
                rownames = F,
                options = list(
                  searching = F,
                  pageLength = 6,
                  dom = 'Bfrtip',
                  buttons = c('csv')))

```

####

#### DICs Mean IBD {.tabset .tabset-fade}
##### Greater Circle DICs 
```{r, results='asis'}

provmodels %>% 
  dplyr::select(c("formula", "distcat", "min_nEff", "DIC")) %>% 
  dplyr::filter(distcat == "gcdistance") %>% 
  dplyr::filter(outcome == "meanprovIBD" ) %>% 
  DT::datatable(.,
                rownames = F,
                options = list(
                  searching = F,
                  pageLength = 6,
                  dom = 'Bfrtip',
                  buttons = c('csv')))

```

##### Road DICs 
```{r, results='asis'}

provmodels %>% 
  dplyr::select(c("formula", "distcat", "min_nEff", "DIC")) %>% 
  dplyr::filter(distcat == "roaddistance") %>% 
  dplyr::filter(outcome == "meanprovIBD" ) %>% 
  DT::datatable(.,
                rownames = F,
                options = list(
                  searching = F,
                  pageLength = 6,
                  dom = 'Bfrtip',
                  buttons = c('csv')))

```

##### River DICs 
```{r, results='asis'}

provmodels %>% 
  dplyr::select(c("formula", "distcat", "min_nEff", "DIC")) %>% 
  dplyr::filter(distcat == "riverdistance") %>% 
  dplyr::filter(outcome == "meanprovIBD" ) %>% 
  DT::datatable(.,
                rownames = F,
                options = list(
                  searching = F,
                  pageLength = 6,
                  dom = 'Bfrtip',
                  buttons = c('csv')))

```

####



### Long Chain Runs
Note, our goal is still to have the effective sample sizes (`n.effective`) to be at least 1,000 for all parameters. In addition, we will visually check for convergence among the four chains.  
  
**Looks like the slope fitting models failed miserably. Going to drop those going forward**. 

##### Long Chain Param Diagnostics
```{r}

```
