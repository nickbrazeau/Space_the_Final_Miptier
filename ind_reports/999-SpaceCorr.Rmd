---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Spatial Autocorrelation EDA for Gaussian Processes
Note, using the vignette/resource provided by [Giorgi & Diggle 2017](https://www.jstatsoft.org/article/view/v078i08) and `rgeos`.

```{r, include=FALSE}
knitr::opts_chunk$set(echo = T, warning = F, message = F, eval = T, results = 'hide',
                      fig.align = 'center', fig.width = 8, fig.height = 8)
knitr::opts_knit$set(root.dir = here::here())
```

```{r}

set.seed(48)
library(tidyverse)
library(PrevMap)
library(raster)
library(cowplot)
source("R/themes.R")
source("R/basics.R")
# load pretty map aesthetics 
DRCprov <- sf::st_as_sf(readRDS("data/map_bases/gadm/gadm36_COD_1_sp.rds"))
load("data/map_bases/space_mips_maps_bases.rda")
drccites <- readr::read_csv("data/map_bases/DRC_city_coordinates.csv") %>%
  dplyr::filter(population > 350000)
```

```{r}
#..............................................................
# read in data
#......................
# cluster names
#...................... 
clsts <- readRDS("data/derived_data/sample_metadata.rds") %>%
  dplyr::select(c("hv001", "longnum", "latnum")) %>%
  dplyr::filter(!duplicated(.)) %>%
  tibble::as_tibble(.) %>%
  dplyr::mutate(hv001 = as.character(hv001))

#......................
# covar data
#......................
covars <- readRDS("data/derived_data/covar_rasterstack_samplinglocations_scaled.RDS") %>% 
  dplyr::mutate(hv001 = as.character(hv001))

#......................
# inbreeding data -- join and nest
#......................
clst_inbd <- readRDS("results/clust_inbd_results/min_cost_inbreedingresults/min_cost_inbreedingresults.RDS") %>%
  dplyr::select(c("spacetype", "inbreed_ests")) %>%
  tidyr::unnest(cols = inbreed_ests) %>% 
  dplyr::rename(hv001 = param) %>% 
  dplyr::left_join(., clsts, by = "hv001") %>% 
  dplyr::left_join(., covars, by = "hv001") %>% 
  tidyr::nest()

```


## Raw Space

```{r, results='asis'}
uvec <- c(seq(0, 1, by = 0.2), seq(1, 10))

pvclust.weighted.geodata <- geoR::as.geodata(obj = pvclust.weighted.nosf,
                                             coords.col = c("longnum", "latnum"),
                                             data.col = "plsmdn",
                                             covar.col = riskvars)

plot(pvclust.weighted.geodata)

```


#### Case-Variogram

```{r, results='asis'}

pv.vario.counts <- geoR::variog(pvclust.weighted.geodata,
                                bin.cloud = T,
                                uvec = uvec)

par(mfrow = c(1,3))
points(pvclust.weighted.geodata, xlab = "Coord X", 
       ylab = "Coord Y",
       cex.max = 0.7, col = gray(seq(1, 0.1, l = 100)),
       pt.divide = "equal")
plot(pv.vario.counts)

plot(pv.vario.counts, bin.cloud = T)
mtext("Empirical Variogram for P.vivax Counts", side = 3,  line = -6, outer = TRUE)

graphics.off()

```

This does not indicate a great degree (if any) spatial structuring. The classic variogram should follow a log-curve and have a sill that is reached at some distance. Of note, the potential nugget effect here is huge.  



#### Estimation of Variogram Parameters
I.e. nugget effect, sill, and range. Will test a Matern and Exponential Covariance and compare. 
```{r}

#..........................
# Maximum Likelihood
#..........................
ml.exp <- likfit(pvclust.weighted.geodata, 
                 ini = c(1, 0.5),
                 cov.model = "exp",
                 fix.nugget = F, 
                 nugget = 0,
                 fix.kappa = F)

ml.matern <- likfit(pvclust.weighted.geodata, 
                    ini = c(1, 0.5),
                    cov.model = "matern",
                    fix.nugget = F, 
                    nugget = 0,
                    fix.kappa = F)

#..........................
# OLS
#..........................

ols.exp <- variofit(pv.vario.prev, 
                    ini = c(1, 0.5),
                    cov.model = "exp",
                    fix.nugget = F, 
                    nugget = 0,
                    fix.kappa = F) 

ols.matern <- variofit(pv.vario.prev, 
                       ini = c(1, 0.5),
                       cov.model = "matern",
                       fix.nugget = F, 
                       nugget = 0,
                       fix.kappa = F)



par(mfrow = c(1, 2))
plot(pv.vario.prev, main = "Maximum Likelihood Estimation")
lines(ml.exp, max.dist = 20, lty = 1, lwd = 2)
lines(ml.matern, max.dist = 20, lty = 2, lwd = 2, col = "red")
legend(2, 4, legend = c("Exp", "Matern"), 
       lty = c(1, 2), col = c("black", "red"), cex = 0.7)

plot(pv.vario.prev, main = "Ordinary Least Square")
lines(ols.exp, max.dist = 20, lty = 1, lwd = 2)
lines(ols.matern, max.dist = 20, lty = 2, lwd = 2, col = "red")
legend(2, 4, legend = c("Exp", "Matern"), 
       lty = c(1, 2), col = c("black", "red"), cex = 0.7)

graphics.off()

```
Truly impressive lack of spatial structure. From models above, an appropriate _kappa_ value fro the Matern covariance matrix appeared to be 0.5 or 1. Let's explore that specifically below.

#### Matern Shape
```{r}
#......................
# Matern Shape, K
#......................

# look at kappa smooth parameter for matern covariance
profile.kappa <- invisible( PrevMap::shape.matern(plsmdlogit ~ 1,
                                                  coords = ~ longnum + latnum,
                                                  data = pvclust.weighted.nosf,
                                                  set.kappa = seq(0.1, 10, length = 16),
                                                  start.par = c(0.2, 0.05), # starting values for the scale parameter phi and the relative variance of the nugget effect nu2
                                                  coverage = NULL # CI coverage
) )



```

```{r, results='asis'}

plot(profile.kappa)
abline(v = 1, col = "blue", lty = 2)
```
The max _kappa_ value was found to be `r profile.kappa$set.kappa[ which(profile.kappa$val.kappa == max(profile.kappa$val.kappa)) ]`. Will set it to 1 (fixed now in subsequent analyses).


